"""Different type checkers, adapted to the needs of the transistor database."""
# Python standard libraries
import numpy as np
import logging
logger = logging.getLogger(__name__)

def check_realnum(float_to_check: float) -> bool:
    """
    Check if argument is real numeric scalar.

    Raise TypeError if not. None is also accepted because it is valid for
    optional keys. Mandatory keys that must not contain None are checked somewhere else beforehand.

    :param float_to_check: input argument
    :type float_to_check: float

    :raises TypeError: if float_to_check is not numeric

    :return: True in case of numeric scalar.
    :rtype: bool
    """
    if isinstance(float_to_check, (int, float, np.integer, np.floating)) or float_to_check is None:
        return True
    raise TypeError(f"{float_to_check} is not numeric.")


def check_2d_dataset(dataset_to_check: np.array) -> bool:
    """
    Check if argument is real 2D-dataset of right shape.

    None is also accepted because it is
    valid for optional keys. Mandatory keys that must not contain None are checked somewhere else beforehand.

    :param dataset_to_check: 2d-dataset
    :type dataset_to_check: np.array

    :raises TypeError: if the passed argument is a 2D-numpy array with real numeric values

    :return: True in case of valid 2d-dataset
    :rtype: bool
    """
    if dataset_to_check is None:
        return True
    if isinstance(dataset_to_check, np.ndarray):
        if np.all(np.isreal(dataset_to_check)):
            if dataset_to_check.ndim == 2:
                if dataset_to_check.shape[0] == 2:
                    return True
    raise TypeError("Invalid dataset. Must be 2D-numpy array with shape (2,x) and real numeric values.")


def check_str(string_to_check: str) -> bool:
    """
    Check if argument is string.

    Function not necessary but helpful to keep raising of errors
    consistent with other type checks. None is also accepted because it is valid for optional keys. Mandatory keys that
    must not contain None are checked somewhere else beforehand.

    :param string_to_check: input string
    :type string_to_check: str
    :raises TypeError: if the argument is not of type string
    :return: True in case of valid string
    :rtype: bool
    """
    if isinstance(string_to_check, str) or string_to_check is None:
        return True
    raise TypeError(f"{string_to_check} is not a string.")


def csv2array(csv_filename: str, first_xy_to_00: bool = False, second_y_to_0: bool = False,
              first_x_to_0: bool = False, mirror_xy_data: bool = False) -> np.array:
    """
    Import a .csv file and extracts its input to a numpy array.

    Delimiter in .csv file must be ';'. Both ',' or '.'
    are supported as decimal separators. .csv file can generated from a 2D-graph for example via
    https://apps.automeris.io/wpd/

    .. todo: Check if array needs to be transposed? (Always the case for webplotdigitizer)

    :param csv_filename: Insert .csv filename, e.g. "switch_channel_25_15v"
    :type csv_filename: str
    :param first_xy_to_00: Set 'True' to change the first value pair to zero. This is necessary in
        case of webplotdigitizer returns the first value pair e.g. as -0,13; 0,00349.
    :type first_xy_to_00: bool
    :param second_y_to_0: Set 'True' to set the second y-value to zero. This is interesting in
        case of diode / igbt forward channel characteristic, if you want to make sure to set the point where the ui-graph
        leaves the u axis on the u-point to zero. Otherwise there might be a very small (and negative) value of u.
    :type second_y_to_0: bool
    :param first_x_to_0: Set 'True' to set the first x-value to zero. This is interesting in
        case of nonlinear input/output capacities, e.g. c_oss, c_iss, c_rss
    :type first_x_to_0: bool
    :param mirror_xy_data: Takes the absolute() of both axis. Used for given mirrored data,
        e.g. some datasheet show diode data in the 3rd quadrant instead of the 1st quadrant
    :type mirror_xy_data: bool

    :return: 1d array, ready to use in the transistor database
    :rtype: np.array
    """
    # See issue #5: German csv-files use ; as separator, english systems use , as separator
    # if ; is available in the file, csv-file generation was made by a german-language operating system
    file1 = open(csv_filename, "r")
    readfile = file1.read()
    if ';' in readfile:
        # csv-file was generated by a german language system
        array = np.genfromtxt(csv_filename, delimiter=";",
                              converters={0: lambda s: float(s.decode("UTF-8").replace(",", ".")),
                                          1: lambda s: float(s.decode("UTF-8").replace(",", "."))})
    else:
        # csv-file was generated by a english language system
        array = np.genfromtxt(csv_filename, delimiter=",")
    file1.close()

    if first_xy_to_00:
        array[0][0] = 0  # x value
        array[0][1] = 0  # y value

    if second_y_to_0:
        array[1][1] = 0  # y value

    if first_x_to_0:
        array[0][0] = 0  # x value

    if mirror_xy_data:
        array = np.abs(array)

    return np.transpose(array)


def check_float(float_to_check: int | float) -> bool:
    """
    Check if argument is a float.

    :param float_to_check: number to check
    :type float_to_check: int | float

    :return: True for float, False for everything else
    :rtype: bool
    """
    try:
        float(float_to_check)
        return True
    except ValueError:
        return False


def check_keys(keys_to_check: dict, req_type: str, switch_type: str):
    """
    Find_next_gate_voltage method of class type - switch and diode (Helper method).

    Verifies if the required keys are available and their value types are valid for carrying out the export
    Used for export_gecko() and export_plecs()

    :param keys_to_check: the dictionary which contains the essential keys for the corresponding exporter function
    :type keys_to_check: dict
    :param req_type: 'plecs' or 'gecko' type for passed during respective exporter function calls
    :type req_type: str
    :param switch_type: 'diode' or 'switch'
    :type switch_type: str

    :raises KeyError: when not all the required keys are available for the chosen exporter functions
    :raises ValueError: if the key values are None

    """
    default_key_dict = {'plecs': ('v_channel_gs', 'v_d_off'),
                        'gecko': ('v_channel_gs', 'v_supply', 'v_d_off')}.get(req_type) if switch_type == 'diode' else \
        {'plecs': ('v_channel_gs', 'v_g_on', 'v_g_off'),
         'gecko': ('v_channel_gs', 'v_supply', 'v_g_on', 'v_g_off')}.get(req_type)
    if all(key in list(keys_to_check.keys()) for key in default_key_dict):
        for value in keys_to_check.values():
            if value is None:
                raise ValueError
            else:
                check_realnum(value)
    else:
        raise KeyError("Not all keys exists for re-estimating gate voltages")


def check_duplicates(current_items: list[dict], item_to_append: dict) -> bool:
    """
    Check if the item being added already exists in the list (Helper method).

    :param current_items: list of particular class object converted to dictionaries using which the checks are conducted
    :type current_items: list(dict)
    :param item_to_append: the object dict that needs to be appended
    :type item_to_append: dict

    :return: True if the added item is not duplicate
    :rtype: bool
    """
    if len(current_items) == 0:
        return True
    else:
        for index, c_item in enumerate(current_items):
            count = 0
            for key, _ in c_item.items():
                if isinstance(item_to_append[key], np.ndarray):
                    count = count + 1 if c_item[key].tolist() == item_to_append[key].tolist() else count
                elif c_item[key] == item_to_append[key]:
                    count += 1
            if count == len(c_item):
                msg = "Duplicate object detected: already present at index {0} of {1} object" .format(index, type(current_items).__name__)
                logger.info(msg)
                return False
        return True
